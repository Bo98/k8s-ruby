#!/usr/bin/env ruby

require 'optparse'
require 'uri'
require 'pharos-kube-client'

Options = Struct.new(
  :config,
  :server,
  :insecure_skip_tls_verify,
  :namespace,
  :all_namespaces,
  :pipeline_list,
  :label_selector,
  :list_resources,
  :list_pods,
  :update_node,
  :node_unschedulable
)

options = Options.new()
logger = Logger.new(STDERR)

parser = OptionParser.new do |parser|
  parser.on('--kubeconfig=PATH') do |path|
    options.config = Pharos::Kube::Config.load_file(path)
  end
  parser.on('--server=SERVER') do |server|
    options.server = URI(server)
  end
  parser.on('--insecure-skip-tls-verify') do
    options.insecure_skip_tls_verify = true
  end
  parser.on('-n', '--namespace=NAMESPACE') do |namespace|
    options.namespace = namespace
  end
  parser.on('--all-namespaces') do
    options.all_namespaces = true
  end
  parser.on('-l', '--label-selector=LABEL=VALUE') do |selector|
    options.label_selector = selector
  end
  parser.on('--pipeline-list') do
    options.pipeline_list = true
  end
  parser.on('--list-resources') do
    options.list_resources = true
  end
  parser.on('--list-pods') do
    options.list_pods = true
  end
  parser.on('--update-node=NODE') do |node|
    options.update_node = node
  end
  parser.on('--node-unschedulable=BOOL', TrueClass) do |bool|
    options.node_unschedulable = bool
  end
end

parser.parse!

if options.config
  client = Pharos::Kube::Client.config(options.config)
else
  client = Pharos::Kube.client(options.server.to_s,
    ssl_verify_peer: !options.insecure_skip_tls_verify,
  )
end

logger.info "Kube server version: #{client.version[:gitVersion]}"

if options.all_namespaces
  namespace = nil # all
elsif options.namespace
  namespace = options.namespace
elsif options.config && ns = options.config.context.namespace
  namespace = ns
else
  namespace = nil # all
end

if options.list_resources
  ([client.api] + client.apis(prefetch_resources: true)).each do |api|
    logger.info "api=#{api.api_version}"

    resources = api.resources.select{|resource| resource.list? }

    if options.pipeline_list
      objects = api.list_resources(resources, namespace: namespace, labelSelector: options.label_selector)
      objects.each do |object|
        logger.info "api=#{object.apiVersion} kind=#{object.kind} namespace=#{object.metadata.namespace} name=#{object.metadata.name}"
      end
    else
      resources.each do |resource|
        logger.info "api=#{api.api_version} resource=#{resource.name}"

        objects = resource.list(labelSelector: options.label_selector)
        objects.each do |object|
          logger.info "api=#{object.apiVersion} kind=#{object.kind} namespace=#{object.metadata.namespace} name=#{object.metadata.name}"
        end
      end
    end
  end
end

if options.list_pods
  client.api('v1').resource('pods', namespace: namespace).list.each do |pod|
    puts "namespace=#{pod.metadata.namespace} pod: #{pod.metadata.name} node=#{pod[:spec][:nodeName]}"
  end
end

if options.update_node
  node = client.api('v1').resource('nodes').get(options.update_node)

  puts "Update node=#{node.metadata.name}..."

  if !options.node_unschedulable.nil?
    puts "Set node=#{node.metadata.name} unschedulable: #{node[:spec][:unschedulable]} => #{options.node_unschedulable}"

    node[:spec][:unschedulable] = options.node_unschedulable
  end

  client.api('v1').resource('nodes').update(node)
end
